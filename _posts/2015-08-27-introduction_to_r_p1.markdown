---
layout:     post
title:      "Основы R, типы данных часть 1"
date:       2015-09-02 12:00:00
author:     "Vasiliy Zemlyanov"
header-img: "img/post-bg-02.jpg"
---

#Язык программирования R

**R** - язык программирования и программная среда предназначенная для статистических вычислений. Получил широкое распространение в среде статистических вычислений, анализе данных и как средство для построения графиков.

`R` содержит набор средств, позволяющих проводить моделирование, классификацию, кластеризацию, визуализацию данных, анализ временных рядов,  машинное обучение и другие полезные вещи.

Язык доступен для всех современных платформ и легко расширяется за счет пакетов, которые реализуют новые модели, дополнительные графические возможности и расширяют возможности обработки данных.

Является open-source реализацией языка `S`, разработанного в Bell Labs.

Недостатками `R` являются нетривиальный синтаксис, который требует привыкания, и относительно медленная скорость работы.

#Основы

`R` доступен для всех современных операционных систем, и поставляется с полноценной REPL средой.
Интерактивную консоль можно использовать для простых экспериментов, в качестве калькулятора и для чтения документации.

Первое что бросается в глаза: `R` в отличии от большинства языков программирования в качестве оператора присваивания использует `<-` вместо `=`. На самом деле и `=` работает, разница в использовании операторов в области видимости переменной.
В разных style guide-ах можно найти противоположные рекомендации по использованию операторов присваивания, но в сообществе `R` разработчиков более распространен первый вариант '<-', его я и буду использовать в данном цикле статей. 

{% highlight R %}
#  Комментарии начинаются со знака слеша.
#  Создадим нескольких переменных
> width <- 5
> height <- 4

# Используем для дальнейших вычислений
> square <- width * height
> perimeter <- 2 * (height + width)
> square
[1] 20
> perimeter
[1] 18

# Функция "ls" - отображает переменные в текущем окружении
> ls()
[1] "height" "width" "square" "perimeter"

# Функция "rm" - удаляет переменную из окружения
> rm(perimeter)
> ls()
[1] "height" "width" "square"
{% endhighlight %}

Для полноценных программ исходный код сохраняется в `R-скрипты`, файлы с расширением `.R`. 

{% highlight R %}
# Функция "cat" используется для вывода в консоль или файл
cat("Compute the square of circle.\n")
r <- 3 
square <- pi * r ^ 2
cat(square)
{% endhighlight %}

Исполняется такой скрипт командой `Rscript square.R`. Или можно просто поставить IDE, например [RStudio](https://www.rstudio.com/), open source версия которой доступна для всех платформ.

Получить дополнительную информацию по любой функции `R` можно используя встроенную документацию. Для этого перед именем функции нужно допечатать `?`. 
В документации хранится описание функции, полный список аргументов и примеры.

{% highlight R %}
> ?sum
Sum of Vector Elements

Description
sum returns the sum of all the values present in its arguments.

Usage
sum(..., na.rm = FALSE)
Arguments

... 
numeric or complex or logical vectors.
na.rm   
logical. Should missing values (including NaN) be removed?
Details

This is a generic function: methods can be defined for it directly or via the Summary group generic. For this to work properly, the arguments ... should be unnamed, and dispatch is on the first argument.
{% endhighlight %}

Или просто поискать название функции в интернете.

##Logical

Самым простым является логический тип данных `logical`. К нему относятся значения `TRUE` и `FALSE`, можно просто `T` и `F`. Еще `logical` соответствует значение `NA`, но сейчас это неважно.

Для определить к какому типу относится переменная есть функция  `class()`, которая принимает переменную и возвращает ее тип. 

{% highlight R %}
> variable <- FALSE
class(variable)
[1] "logical"

> class(TRUE)
[1] "logical"
{% endhighlight %}

Для `logical` переменных определены основные логические операции.

{% highlight R %}
> TRUE && (FALSE || TRUE)
[1] TRUE

> xor(TRUE, FALSE)
[1] TRUE

> !TRUE
[1] FALSE
{% endhighlight %}

##Numeric

Числовой тип данных представлен `numeric` и поддерживает основные арифметические операции.

{% highlight R %}
# Ничего интересного
> 1984
[1] 1984

> 2.7118
[1] 2.7118

> 3 + 8.4
[1] 11.4

# Возведение в степень
> 7 ^ 4
[1] 2401

# Остаток деления, mod
> 9 %% 2
[1] 1

# Целочисленное деление, div
> 9 %/% 2
[1] 4
{% endhighlight %}

Частным случаем `numeric` является целочисленный тип `integer`. Для указания что число является `integer` к нему дописывается `L`.

{% highlight R %}
# Это numeric
> class(13)
[1] "numeric"

# А это integer
> class(13L)
[1] "integer"
{% endhighlight %}

Все `integer` являются `numeric`, но не все `numeric` являются `integer`.

##Character

Для хранения строк есть `character`, тут все просто.

{% highlight R %}
> "Hello, World!"
[1] "Hello World!"

# Конкатенация строк производится функцией "paste", "+" не работает для строк!
> name <- "John"
> surname <- "Galt"
> character <- paste(name, surname)
character
[1] "John Galt"

# Печатаем строку
> sprintf("Who is has %s?", character)
[1] "Who is has John Gult??"

# Получаем подстроку
> substr("Answer to the Ultimate Question of Life, the Universe, and Everything", start = 23, stop = 39)
[1] " Question of Life"

# Заменяем подстроку
> sub("problem", "dream!", "I have a problem")
[1] "I have a dream!"
{% endhighlight %}

##Complex

Тип данных для операций с комплексными числами:

{% highlight R %}
# Создание комплексного числа
> z <- 2 + 1i
> z
[1] 2+1i

# Действительная часть
> Re(z)
[1] 2

# Мнимая часть
> Im(z)
[1] 1

# Модуль
> Mod(z)
[1] 2.236068

# Аргумент
> Arg(z)
[1] 0.4636476

# Сопряженное комплексное число
> Conj(z)
[1] 2-1i
{% endhighlight %}

##Определяем и конвертируем типы
Чтобы проверить, принадлежит ли переменная к какому-либо типу можно использовать функции вида `is.*`:

{% highlight R %}
# Возвращаясь к numeric и integer
> is.numeric(5)
[1] TRUE

> is.numeric(5L)
[1] TRUE

> is.integer(3)
[1] FALSE

> is.integer(3L)
[1] TRUE

##Другие типы
> is.character("Mew!")
[1] TRUE

> is.logical(FALSE)
[1] TRUE
{% endhighlight %}

Для конвертации типов используются функции вида `as.*`:

{% highlight R %}
# logical в numeric
> as.numeric(TRUE)
[1] 1

> as.numeric(FALSE)
[1] 0

# numeric в character
> as.character(8)
[1] "8"

# character в numeric
> as.numeric("4.2")
[1] 4.2

# character в integer
> as.integer("4.2")
[1] 4

# а так делать нельзя
> as.numeric("This is not a number!")
[1] NA
Warning message:
NAs introduced by coercion 
{% endhighlight %}

#Векторы

Вектор в `R` это набор элементов одного типа.
Создаются векторы функцией `c()`, сокращение от *combine*.

{% highlight R %}
# Вектор чисел
> remain <- c(10, 11, 13, 8)
> remain
[1] 10 11 13 8

> is.vector(remain)
[1] TRUE

# Вектор строк
> suits <- c("spades", "hearts", "diamonds", "clubs")
> suits
[1] "spades" "hearts" "diamonds" "clubs"   

# Длина вектора получается функцией `length()`
> length(remain)
[1] 4

# Сумма элементов функцией `sum()`
> sum(remain)
[1] 42
{% endhighlight %}

Каждому элементу вектора можно присвоить имя. Сделать это можно несколькими способами:

{% highlight R %}
# С помощью функции names()
> names(remain) <- suits
> remain
spades hearts diamonds clubs
    10     11       13     8

# Во время создания объекта
remain <- c("spades" = 10, "hearts" = 11, "diamonds" = 13, "clubs" = 8) 
# Имена можно не заключать в кавычки
remain <- c(spades = 10, hearts = 11, diamonds = 13, clubs = 8)
{% endhighlight %}

На самом деле, все базовые типы `R` являются векторами из 1 элемента.

{% highlight R %}
> day_number <- 1
> day_title <- "Monday"

> is.vector(day_number)
[1] TRUE

> is.vector(day_title)
[1] TRUE

> length(day_number)
[1] 1

> length(day_title)
[1] 1
{% endhighlight %}

При попытке создать вектор содержащий элементы нескольких типов, все элементы будут приведены к наиболее общему типу.

{% highlight R %}
# Все numeric будут конвертированы в character
> marks <- c(4, 5, "A", "F")
> marks
[1] "4" "5" "A" "F"

>class(manks)
[1] "character"
{% endhighlight %}

##Вычисления с векторами

Операции над векторами выполняются *поэлементно*:

{% highlight R %}
> earnings <- c(10, 20, 30)
> earnings * 3
[1] 30 60 90

> sqrt(earnings)
[1] 3.162278 4.472136 5.477226

# Операции над несколькими векторами так же выполняются поэлементно
> expenses <- (5, 10, 40)
> earnings - expenses
[1] 5 10 -10

> earnings * c(1, 2, 3)
[1] 10 40 90

> earnings / c(1, 2, 3)
[1] 10, 10, 10

# Каждый элемент вектора можно проверить на соответсиве условию и получить вектор logic значений
> earnings > 15
[1] FALSE TRUE TRUE
{% endhighlight %}

##Элементы вектора, подмножества векторов

Обращение к элементам вектора происходит по индексу или имени, заключенному в квадратные скобки `[]`. Об плохом: *индексация в R начинается с 1.*

{% highlight R %}
> remain <- c(spades = 10, hearts = 11, diamonds = 13, clubs = 8)
# По индексу
> remain[1]
spades
    10

# По имени
> remain["hearts"]
hearts
    11
{% endhighlight %}

Можно получить несколько элементов вектора, используя числовой вектор или вектор строк.

{% highlight R %}
# По индесам
> remain[c(1, 4)]
spades clubs
    10     8

# По именам
> remain[c("diamonds", "hearts")]
diamonds hearts
      13     11     
{% endhighlight %}

Удалить элементы вектора можно допечатав перед индексом исключаемого элемента знак минус `-`. Исключать элементы по именам нельзя, только по индексам.

{% highlight R %}
# Новый вектор, содержащий все элементы remain кроме третьего
> new_remain < remain[-3]
> new_remain
spades hearts clubs
    10     11     8

# Можно исключить сразу несколько элементов
> remain[-c(1, 3)]
hearts clubs
    11     8
{% endhighlight %}

Подмножество элементов можно получить используя вектор `logic` значений. Будут выбраны элементы индексам которых соответствует значение `TRUE`.

{% highlight R %}
# Выбираем второй и четвертый элементы
> remain[c(FALSE, TRUE, FALSE, TRUE)]
hearts clubs
    11     8

# Если элементов в передаваемом векторе недостаточно, вектор будет зациклен до нужной длины
> remain[c(FALSE, TRUE)]
hearts clubs
    11     8

# Выбираем нечетные элементы
>remain[remain %% 2 != 0]
hearts diamonds
    11       13 
{% endhighlight %}

#Матрицы

Матрица расширяет понятие вектора. Это тот же самый вектор, который может содержать элементы только одного типа, но теперь двумерный.
Создается матрица функцией `matrix()`, с указанием количества строк или столбцов.

{% highlight R %}
# Матрица содержащая элементы от 1 до 6 в две строки
> matrix(1:6, nrow = 2)
> matrix(1:6, nrow = 2)
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

# В два столбца
> matrix(1:6, ncol = 2)
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6

# По умолчанию матрица заполняется по столбцам, для заполнения по строкам нужен параметр "byrow"
> matrix(4:11, nrow = 2, byrow = TRUE)
     [,1] [,2] [,3] [,4]
[1,]    4    5    6    7
[2,]    8    9   10   11

# Если элементов недостаточно для заполнения всех строк и столбцов они будут циклически повторяться
> matrix(1:3, nrow = 3, ncol = 4, byrow = TRUE)
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    1
[2,]    2    3    1    2
[3,]    3    1    2    3
{% endhighlight %}

Второй способ создания матрицы состоит в комбинировании векторов по строкам или по столбцам, функциями `rbind` и `cbind` соответственно.

{% highlight R %}
> rbind(1:3, 7:9)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    7    8    9

> cbind(4:6, 1:3)
     [,1] [,2]
[1,]    4    1
[2,]    5    2
[3,]    6    3
{% endhighlight %}

Используя `rbind` и `cbind` можно добавить строку или столбец к уже существующей матрице.

{% highlight R %}
> m <- matrix(1:6, byrow = TRUE, nrow = 2)
> m
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6

> rbind(m, 7:9)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9

> cbind(m, c(10:11))
     [,1] [,2] [,3] [,4]
[1,]    1    2    3   10
[2,]    4    5    6   11
{% endhighlight %}

Строкам и столбцам матрицы можно присваивать имена, используя функции `rownames` и `colnames` соответственно. Строки и столбцы могут быть проименованы и в момент создания матрицы параметром `dimnames`.

{% highlight R %}
> m <- matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE)
# Называем стоки
> rownames(m) <- c("row1", "row2", "row3")
# Называем столбцы
> colnames(m) <- c("col1", "col2", "col3")
> m
     col1 col2 col3
row1    1    2    3
row2    4    5    6
row3    7    8    9

# При создания матрицы
> m <- matrix(1:9, byrow = TRUE, nrow = 3, ncol = 3,
                dimnames = list(c("row1", "row2", "row3"),
                                c("col1", "col2", "col3")))
{% endhighlight %}

Как и векторы, матрицы могут хранить элементы только одного типа. При попытке сохранить в одной матрице элементы нескольких типов, или соединить матрицы разных типов используя `rbind` и `cbind` все элементы будут приведены к наиболее общему типу.

##Элементы матрицы, подмножества матриц

Для выбора элементов матрицы используются те же техники что и для векторов, с поправкой на двумерность матрицы.

{% highlight R %}
# Выбираем элемент из первой строки, третьего столбца
> m[1, 3]
[1] 3
{% endhighlight %}

Строку или столбец матрицы можно получить не указывая один из индексов.

{% highlight R %}
# Выбираем вторую строку
> m[2, ]
col1 col2 col3 
   4    5    6 

# Выбираем третий столбец
> m[, 3]
row1 row2 row3 
   3    6    9 
{% endhighlight %}

Можно выбирать сразу несколько элементов. Принципы те же, что и с векторами.

{% highlight R %}
# Элементы на пересечении второй строки, первого и третьего столбца
> m[2, c(1, 3)]
col1 col3 
   4    6 

# Подматрица, состоящая из элементов на пересечении 1, 3 строк и 1, 3 столбцов
> m[c(1, 3), c (1, 3)]
     col1 col3
row1    1    3
row3    7    9
{% endhighlight %}

Элементы можно выбрать используя имена строк и столбцов.

{% highlight R %}
> m[c("row1", "row3"), "col1"]
row1 row3 
   1    7 

# Индексы и имена можно использовать вместе
> m[2, c("col2", "col3")]
col2 col3 
   5    6 
{% endhighlight %}

## Использование матриц

Над матрицами можно выполнять все стандартные арифметические операции. Все они выполняются поэлементно, включая умножение и деление.

{% highlight R %}
# Переменная будет добавлена к каждому элементу
> m + 3
     col1 col2 col3
row1    4    5    6
row2    7    8    9
row3   10   11   12

# Функция применяется к каждом элементу
> log(m)
         col1      col2     col3
row1 0.000000 0.6931472 1.098612
row2 1.386294 1.6094379 1.791759
row3 1.945910 2.0794415 2.197225

# "rowSums" возвращает сумму элементов каждой строки
> rowSums(m)
row1 row2 row3 
   6   15   24 

# "colSums" возвращает сумму элементов каждого столбца
> colSums(m)
col1 col2 col3 
  12   15   18 

# Транспонирование матриц осуществляется функцией "t()"
> t(m)
     row1 row2 row3
col1    1    4    7
col2    2    5    8
col3    3    6    9

# Для математической операции перемножения матриц необходимо использовать оператор %*%
> matrix(1:6, nrow = 3) %*% matrix(7:12, ncol = 3)
     [,1] [,2] [,3]
[1,]   39   49   59
[2,]   54   68   82
[3,]   69   87  105
{% endhighlight %}

Получилось достаточно объемно, поэтому об списках, datafram-ах, работе с файлами и графикой я напишу в следующих частях.

