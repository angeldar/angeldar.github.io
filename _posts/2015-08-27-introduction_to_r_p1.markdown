---
layout:     post
title:      "Основы R, типы данных часть 1."
date:       2015-08-25 12:00:00
author:     "Vasiliy Zemlyanov"
header-img: "img/test3.jpg"
---

# Язык программирования R

**R** - язык программирования предназначенный для статистическиз вычислений.
Является open-source реализацией языка S.

Преимущества R

- OpenSource
- Графические возможности
- Переносимость
- Расширения
- Сообщество

Недостатки

- Сложно изучить
- Легко написать код, который будет сложно поддерживать
- Плохо написанный код будет работать медленно

# Обзор edX: DAT204x Introduction to R

Абсолютно базовый курс по R. В курсе дают введение в синтаксис и знакомят с основными структурами данных в R: базовыми типами, массивами, списками, матрицами и datafram-ами.
Сначала предлагается посмотреть простое 5 минутное видео на заданную тему, потом ответить на такие-же простые вопросы по этому виде и пройти интерактивную лабораторную работу на https://campus.datacamp.com.
Я считаю что дать такие основы можно было и быстрее, сэкономив время для более прикладных примеров работы с R.
Курс подойдет как вводный для тек кто никогда не видел R и хочет с ним ознакомиться, либо тех кто уже знаком с R, но хочет быстрой пробежаться по основам.

#Основы

Простые вычисления и эксперементы можно проводить непосредственно в интерактивной консоли R.

Для присваивания в R используется `<-` вместо привычного `=`.

{% highlight R %}
#  Комментарии начинаются со знака слэша.
#  Создадим нескольк переменных
> width <- 5
> height <- 4

# Используем их для дальнейших вычислений
> square <- width * height
> perimeter <- 2 * (height + width)
> square
[1] 20
> perimeter
[1] 18

# Функция "rm" - отображает переменные в текущем окружении
> ls()
[1] "height" "width" "square" "perimeter"

# Функция "rm" - удаляет переменную
> rm(perimeter)
> ls()
[1] "height" "width" "square"
{% endhighlight %}

Для более сложных вычислении стоит создавать R-скрипты, файлы с расширением `.R`. 

{% highlight R %}
"Computer the square of circle."
r <- 3 
square <- pi * r ^ 2
square
{% endhighlight %}

Для запуска скритпа необходимо...

Справку по любой функции R, ее описание и список аргументов, можно получить напечатав `?` перед названием функции.

# Написать пример
{% highlight R %}
?sum
{% endhighlight %}


#Базовые типы данных

Логические значения `TRUE` и `FALSE` соответствуют типу данных `logical`.
Еще `logical` соответсвует значение `NA`, но сейчас это не важно.

Для определения типа данных переменной в R существует функция `class()`, которая принимает переменную и возвращает ее тип. 

{% highlight R %}
> class(TRUE)
[1] "logical"
{% endhighlight %}

`numeric` - числовой тип данных, поддерживает основные арифметические операции.

{% highlight R %}
> 2
[1] 2
> 2.5
[1] 2.5
> 3 + 8.4
[1] 11.4
> 7 ^ 4
[1] 2401
{% endhighlight %}

Частным случаем `numeric` является целочисленный тип `integer`. Для указания что число является целочисленным к нему необходимо дописать `L`.

{% highlight R %}
# Это numeric
> 2
# А это integer
> 2L
{% endhighlight %}

Все `integer` являются `numeric`, но не все `numeric` являются `integer`.

Стороковым типом данных является `character`, тут все просто.

{% highlight R %}
> "Hello, World!"
{% endhighlight %}

Другие базовые типы:
`double`: вещественное число с повышенной точностью;
`complex`: комплексное число;
`raw`: бинарная строка.

#Узнаем тип переменной и конвертируем типы

Для проверки относится ли переменная к какому-либо типу можно использовать функции вида `is.*`:

{% highlight R %}
# Возвращаясь к numeric и integer
is.numeric(5) # TRUE
is.numeric(5L) # TRUE
is.integer(3) # FALSE
is.integer(3L) # TRUE

# Другие типы
is.character("Mew!") # TRUE
is.logical(FALSE) # TRUE
{% endhighlight %}

Для конвертации типов используются функции вила `as.*`:

{% highlight R %}
# logical в numeric
as.numeric(TRUE) # 1
as.numeric(FALSE) # 0

# numeric в character
as.character(8) # "8"

# character в numeric
as.numeric("4.2") # 4.2

# character в integer
as.integer("4.2") # 4

# а так делать нельзя.
as.numeric("Test") # NA
{% endhighlight %}

#Векторы

Вектор в R это набор элементов одного типа.
Создать вектор можно с помощью функции `c()`, что является сокращением от combine.

{% highlight R %}
# Вектор строк
> suits <- c("spades", "hearts", "diamonds", "clubs")
> suits
[1] "hearts", "spades", "diamonds"

> is.vector(suits)
[1] TRUE

# Вектор чисел
> remain <- c(10, 11, 13, 8)
> remain
[1] 10, 15, 13, 8
{% endhighlight %}

Длину вектора можно найти с помощью функции `length()`

{% highlight R %}
> length(remain)
[1] 4
{% endhighlight %}

Каждому элементу вектора можно присвоить имя. Сделать это можно несколькими способами:

{% highlight R %}
# С помощью функции names()
> names(remain) <- suits
> remain
spades hearts diamonds clubs
    10     11       13     8

# Во время создания объекта
remain <- c("spades" = 10, "hearts" = 11, "diamonds" = 13, "clubs" = 8) 
# Имена при этом можно не заключать в кавычки. Прошлая команда равносильна
remain <- c(spades = 10, hearts = 11, diamonds = 13, clubs = 8)
{% endhighlight %}

На самом деле все базовые типы R являются векторами, состоящими из 1 элемента.
{% highlight R %}
> day_number <- 1
> day_title <- "Monday"

> is.vector(day_number)
[1] TRUE
> is.vector(day_title)
[1] TRUE
> length(day_number)
[1] 1
> length(day_title)
[1] 1
{% endhighlight %}

Вектор может содержать элементы только одного типа, поэтому при попытке создать вектор содержащий элементы нескольких типов будет произведена конвертация типов к наиболее общему.

{% highlight R %}
# Все numeric будут конвертированы к более общему типу character
> ranks <- c(1, 4, 9, "A")
> ranks
[1] "1" "4" "9" "A"

>class(ranks)
[1] "character"
{% endhighlight %}

##Вычисления с векторами
Операции над векторами выполняются *поэлементно*.

{% highlight R %}
> earnings <- c(10, 20, 30)
> earnings * 3
[1] 30 60 90

> earnings - 8
[1] 2, 12, 22

# Операции над несколькими векторами так же выполняются поэлементно.
> expenses <- (5, 10, 40)
> earnings - expenses
[1] 5 10 -10

# Операции умножения и деления векторов отличаются от математических, и выполняются поэлементно.
> earnings * c(1, 2, 3)
[1] 10 40 90
> earnings / c(1, 2, 3)
[1] 10, 10, 10

# Найти сумму элементов вектора можно с помощью функции "sum()"
> sum(earnings)
[1] 60

# Так же каждый элемент вектора можно проверить на соответсиве некоторому условию, и получить вектор logic значений.
> earnings > 15
[1] FALSE TRUE TRUE
{% endhighlight %}

##Элементы вектора, подмножества векторов
Разберем как можно получить отдельный элемент, или подмножество элементов вектора.

Обращаться к элементам вектора можно по индексу, используя квадратные скобки `[]`. Об плохом: *индексация в R начинается с 1.*

{% highlight R %}
> remain <- c(spades = 11, hearts = 12, diamonds = 11, clubs = 13)
> remain[1]
spades
    11
{% endhighlight %}

Если элементам вектора были присвоены имена, то обращаться к ним можно используя эти имена в квадратных скобках `[]`.

{% highlight R %}
> remain["hearts"]
hearts
    12
{% endhighlight %}

Можно выбрать сразу несколько элементов вектора, передав в качестве параметра другой вектор, содержащий индексы или имена необходимых элементов.

{% highlight R %}
# Получаем первый и последний элементы по индесам
> remain[c(1, 4)]
spades clubs
    12    13

# Получаем третий и второй элементы по именам
> remain[c("diamonds", "hearts")]
diamonds hearts
      11     12     
{% endhighlight %}

Можно выбрать все элементы вектора, исключив ненужные. Перед индексом исключаемого элемента необходимо добавить знак минус `-`. Исключать элементы по названия нельзя, только по индксам.

{% highlight R %}
# Создадим новый вектор, содержащий все элементы remain, кроме третьего
> new_remain < remain[-3]
> new_remain
spades hearts clubs
    11     12    13

# Можно исключить сразу несколько элементов
> remain[-c(1, 3)]
hearts clubs
    12    13
{% endhighlight %}

Крутой является возможность выбрать подмножество элементов исользуя вектор `logic` значений. При этом выбираются элементы, индексам которых соответствет значение `TRUE`.

{% highlight R %}
# Выбираем второй и четвертый элементы
> remain[c(FALSE, TRUE, FALSE, TRUE)]
hearts clubs
    12    13

# Если в передаваемом в качестве параметра векторе меньше элементов, чем в том, из которого мы производим выборку - передаваемый вектор будет зациклен.
> remain[c(FALSE, TRUE)]
hearts clubs
    12    13

# Выбираем элементы меньше 13
> remain[remain < 13]
spades hearts diamonds
    11     12       11
{% endhighlight %}

#Матрицы

Матрица расширяет понятие вектора. Это тот же самый вектор, который может содержать элементы тольно одного типа, но теперь двумерный.
Матрица создается с помощью функции `matrix()`, с указанием количества строк или столбцов.

##Вставить результаты исполнения кода

{% highlight R %}
# Матрица, содержащая элементы от 1 до 6, содержащая 2 строки
> matrix(1:6, nrow = 2)

# Матрица, содержащая элементы от 1 до 6, содержащая 2 столбцам
> matrix(1:6, ncol = 2)

# По умолчанию матрица заполняется по столбцам, для заполнения по строкам необходимо использовать параметр "byrow"
> matrix(1:6, ncol = 2, byrow = TRUE)

# Если элементов недостаточно для заполнения всех строк и столбцов - они будут циклически повторяться, пока не заполнят всю матрицу
> matrix(1:3, nrow = 3, ncol = 3)
{% endhighlight %}

Второй способ создания матрицы состоит в комбинировании векторов по строкам или по столбцам, функциями `rbind` и `cbind` соответственно.

##Вставить результаты исполнения кода

{% highlight R %}
> rbind(1:3, 7:9)
 
> rbind(4:6, 1:3)
{% endhighlight %}

Используя `rbind` и `cbind` можно добавить строку или столбец к уже существующей матрице.
{% highlight R %}
> m <- matrix(1:6, byrow = TRUE, nrow = 2)
> rbind(m, 7:9)

> cbind(m, c(10:11))
{% endhighlight %}

Так же как и векторам элементам матрицы можно присваивать имена, только теперь присваивать имена необходимо отдельно строкам и столбцам используя функции `rownames` и `colnames`. Названия строк и столбцов можно задать в момент создания матрицы параметром dimnames.

{% highlight R %}
> m <- matrix(1:6, byrow = TRUE, nrow = 2)
# Называем стоки
> rownames(m) <- c("row1", "row2")
# Называем столбцы
> colnames(m) <- c("col1", "col2", "col3")

# То же самое, во время создания матрицы. О том что такое "list" будет рассказано позже.
> m <- matrix(1:6, byrow = TRUE, nrow = 2,
               dimnames = list(c("row1, row2",
                               c("col1", "col2", "col3"))))
{% endhighlight %}

Как и векторы, матрицы могут хранить элементы только одного типа. Поэтому, при попытке сохранить в одной матрице элементы нескольких типов, или соеденить матрицы разных типов используя функции `rbind` и `cbind` все элементы будут приведены к наиболее общему типу.

##Элементы матрицы, подмножества матриц

Для выбора элементов матрицы можно использовать те же техники, что и для векторов, с поправкой на двумерность матрицы.

{% highlight R %}
# Выбираем элемент из первой строки, третьего столбца
> m[1, 3]
{% endhighlight %}

Можно выбрать сразу целую строку, или столбец не указывая один из индексов. В результате получим вектор из элементов необходимой строки или столбца.

{% highlight R %}
# Выбираем вторую строку
> m[2, ]

# Выбираем третий столбец
> m[, 3]
{% endhighlight %}

При необходимости можно выбирать сразу несколько элементов. Принципы те же, что и с векторами.

{% highlight R %}
# Элементы третьей строки, первого и третьего столбца
> m[3, c(1, 3)]

# Подматрица, состоящая из элементов на пересечении 1 и 2 строк и 2, 3 и 6 столбцов
> m[c(1, 2), c (2, 3, 6)]
{% endhighlight %}

Для выбора элементов могут быть использованы имена строк и столбцов.

{% highlight R %}
> rownames(m) <- c("r1", "r2", "r3")
> colnames(m) <- c("a", "b", "c", "d")
m

m(c("r1", "r2"), "c")

# Индексы и имена можно использовать вместе
m[2, c("b", "c")]
{% endhighlight %}

## Использование матриц

Над матрицами можно выполнять все стандартные арифметические операции. Все они выполняются поэлементно, включая умножение и деление.

Несколько полезных функция для работы с матрицами:

{% highlight R %}
# Возвращает вектор, содержащий сумму элементов каждой строки
> rowSums

# Возвращает вектор, содержащий сумму элементов каждого столбца
> colSums

# Пример с конвертацией валют

# Транспонирование матриц осуществляется функцией t

# Для математической операции перемножения матриц необходимо использовать оператор %*%

{% endhighlight %}


