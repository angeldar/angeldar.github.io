---
layout:     post
title:      "Взлом простых шифров."
date:       2015-04-05 12:00:00
author:     "Vasiliy Zemlyanov"
header-img: "img/post-bg-02.jpg"
---

# Взлом простых шифров

Нижеописанные шифры не используются на пратике. Они представляют историческую ценность и могут применяться в различных головоломках.

## Взлом шифра Цезаря

Суть шифра Цезаря очень проста. Мы просто заменяем каждый букву алфавита на следующую или предыдущий на n позиций. Например, для n = 3.

- a -> c
- b -> d
- ...
- x -> a
- z -> b

Таким образом, сообщение **hello world** будет зашифровано как **abra-kadabra**.

Как взломать шифр цезаря.

Лингвисты подсчитали на сколько часто каждая буква алфавита встречается в текстах определенного языка. Применяя частотный анализ находим наиболее часто встречающуюся букву. Т.е. если чаще всего в шифротексте встречается буква *k* - то она наиболее вероятно что при шифровании *e* переходит в *h*, значит *n = 3*.
Зная *n* и метод шифрования ничего не стоит заменить каждую из букв на ее *n*-го предшественника и получить исходный текст.
Либо, можно продолжить работать с частотами символов, взять второй по частоте символ и заменить его на *X*. И так далее, до победного конца.

Примером использования шифра цезаря - является Unix утилита rot13, которая осуществляет шифрование сдвигом символа на 13 позиций. Так как в английском языке 26 букв - двухкратное применение rot13 возвращает исходный текст.

## Взлом шифра Вижинера

В шифре Вижинера каждый символ открытого текста складывается по модулю с символом ключа. Операция используемая при шифровании называется: *сложение по модулю*, *исключающе или*, или сокращенно *xor* [Ссылка на википедию]. Если ключ короче шифруемого сообщения - он дублируется столько раз сколько необходимо. Например шифрование сообщения *houstonwegotaproblem* ключем *nevermore* будет иметь вид:

*houstonwegotaproblem* <br />
*nevermorenevermorene* <br />
---------------------  <br />
*ciphertexthereissome* <br />

Для дешефрования - необходимо сложить шифротекст с ключем. По свойству сложения по модулю. 

*(key ^ message) ^ key = message*

Взлом шифра Вижинера не на много сложнее взлома шифра Цезаря.
Допустим нам известна длина ключа *n = |key|*, тогда рассмотрим символы на позициях *0, n-1, 2n-1...*. Как и в случае с шифром Цезаря - можно предположить, что наиболее часто встречающимся символом будет зашифрованная *e*. Тогда, сложив по модулю *e* с наиболее частым символом - мы получим первый символ ключа. Повторим для второго и последующих символов ключа. Зная ключ - дешифруем сообщение.
В случаях, когда длина ключа не известна - просто выполним указанную процедуру для ключа длины *1, 2, ..., n*.

## Взлом одноразового шифроблокнота

Взлом шифра с правильным использованием одноразового шифроблокнота невозможен. Идея шифра с одноразовым шифроблокнотом состоит в том чтобы сложить исходное сообщение с случайной строкой. Данный шифр обладает абсолютной надежностью и не может быть взломан при наличии у взломщика одного шифротекста.
Почему этот метод практически не используется?
Для дешифрования зашифрованного сообщения необходимо знать ключ. Ключ может быть использован только один раз. При этом длина ключа равна длине сообщения.
А если мы можем передать ключ - почему бы вместо этого не передать сообщение?

В случае если один ключ был использован для шифрования нескольких сообщений - например *m1* и *m2*, все что необходимо сделать взломщику - сложить их по модулю.

*c1 = key ^ m1*
*c2 = key ^ m2*
*c1 ^ c2 = m1 ^ m2*

имея эту информацию - можно восстановить оригинальные сообщения *m1* и *m2*. Например, зная что в ASCII кодировке сложение по модулю пробела с символами *a-z* окажется в диапазоне [65, 90] можно получить символы открытого текста. Чем больше у взломщика сообщений зашифрованых одним ключем - тем проще осуществить взлом шифра.

